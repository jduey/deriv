#! /home/jim/toccata/new-toc --script

(defprotocol Precedence
  (size [_])
  (prec [_] 4))

(defn bracket [outer expr]
  (assert-result r (instance? List r))

  (either (and (< (prec expr) outer)
               (maybe (list "(" (str expr) ")")))
          (string-list expr)))

(deftype Add [f g]
  Precedence
  (size [_]
    (+ (size f) (size g)))

  (prec [_]
    1)

  Stringable
  (string-list [a]
    (comp (string-list f)
          (cons " + " (string-list g)))))

(deftype Mul [f g]
  Precedence
  (size [x]
    (+ (size f) (size g)))

  (prec [_]
    2)

  Stringable
  (string-list [_]
    (comp (bracket 2 f)
          (cons "*" (bracket 2 g)))))

(deftype Pow [f g]
  Stringable
  (string-list [_]
    (comp (bracket 2 f)
          (cons "^" (bracket 3 g))))

  Precedence
  (size [x]
    (+ (size f) (size g)))

  (prec [_] 3))

(deftype Ln [expr]
  Stringable
  (string-list [_]
    (comp (cons "ln(" (string-list expr))
          (list ")")))

  Precedence
  (size [_]
    (size expr)))

(defprotocol Stars
  (add* [g f]
    (Add f g))
  
  (add** [_ f g]
    (Add f g))

  (mul* [g f]
    (Mul f g))

  (mul** [_ f g]
    (Mul f g)))

(defprotocol Operations
  (d [f x])

  (add [f g]
    (add* g f))

  (mul [f g]
    (mul* g f))

  (pow [f g]
    (either (or (map (= 0 g) (fn [_] 1))
                (and (= 1 g) (maybe f)))
            (Pow f g)))

  (ln [f]
    (either (and (= 1 f) (maybe 0))
            (Ln f))))

(defn pown [a n]
  (assert (instance? Integer a))
  (assert (instance? Integer n))

  (either (or (and (= 0 n) (maybe 1))
              (and (= 1 n) (maybe a)))
          (let [b (pown a (div n 2))
                x (either (and (= 0 (rem n 2))
                               (maybe 1))
                          a)]
            (* b b x))))


(extend-type Add
  Operations
  (add [a h]
    (.g a (add (.g a) h)))

  (d [a x]
    (let [f (.f a)
          g (.g a)]
      (Add (d f x) (d g x))))

  Stars
  (add* [g f]
    (add** (.f g) f g)))

(extend-type Mul
  Operations
  (mul [m h]
    (mul (.f m) (mul (.g m) h)))

  (d [m x]
    (let [f (.f m)
          g (.g m)]
      (add (mul f (d g x))
           (mul g (d f x)))))

  Stars
  (mul* [g f]
    (mul** (.f g) f g)))

(extend-type Pow
  Operations
  (d [p x]
    (let [f (.f p)
          g (.g p)]
      (mul (pow f g)
           (add (mul (mul g (d f x)) (.g p -1))
                (mul (ln f) (d g x)))))))


(extend-type Ln
  Operations
  (d [l x]
    (let [expr (.expr l)]
      (mul (d expr x) (pow expr -1)))))

(extend-type String
  Operations
  (d [f x]
    (either (and (= f x)
                 (maybe 1))
            0))

  Precedence
  (size [_]
    1))

(extend-type Integer
  Operations
  (d [n x]
    0)

  (add [f g]
    (either (or (and (= 0 f) (maybe g))
                (and (instance? Integer g)
                     (maybe (+ f g))))
            (Add f g)))

  (mul [f g]
    (either (or (and (= 1 f)
                     (maybe g))
                (and (instance? Integer g)
                     (maybe (* f g))))
            (Mul f g)))

  (pow [f g]
    (either (or (= 0 f)
                (and (instance? Integer g)
                     (maybe (pown f g))))
            (Pow f g)))

  Precedence
  (size [_]
    1)

  Stars
  (add* [g f]
    (either (and (= 0 g) (maybe f))
            (Add g f)))

  (add** [f-g f g]
    (add f-g (add f (.g g))))

  (mul* [g f]
    (either (= 0 g)
            (mul g f)))

  (mul** [f-g f g]
    (mul f-g (mul f (.g g)))))

(defn show [expr]
  (either (let [sz (size expr)]
            (and (> sz 100)
                 (maybe (str "<<" sz ">>"))))
          (str expr)))

(defn nest [n f x]
  (either (and (= 0 n)
               (maybe x))
          (nest (dec n) f (f x))))

(defn deriv [f]
  (let [d-prime (d f "x")]
    (println (str "D("
                  (show f)
                  ") = " (show d-prime)))
    d-prime))

(main [[_ depth-str]]
  (nest (str-to-int depth-str)
        deriv (Pow "x" "x")))
