#! /home/jim/toccata/new-toc --script

(defprotocol Precedence
  (size [_])
  (prec [_] 4))

(defn bracket [outer expr]
  (assert-result r (instance? List r))

  (either (and (< (prec expr) outer)
               (maybe (list "(" (str expr) ")")))
          (string-list expr)))

(deftype Add [f g]
  Precedence
  (size [_]
    (+ (size f) (size g)))

  (prec [_]
    1)

  Stringable
  (string-list [a]
    (comp (string-list f)
          (cons " + " (string-list g)))))

(deftype Mul [f g]
  Precedence
  (size [x]
    (+ (size f) (size g)))

  (prec [_]
    2)

  Stringable
  (string-list [_]
    (comp (bracket 2 f)
          (cons "*" (bracket 2 g)))))

(deftype Pow [f g]
  Stringable
  (string-list [_]
    (comp (bracket 2 f)
          (cons "^" (bracket 3 g))))

  Precedence
  (size [x]
    (+ (size f) (size g)))

  (prec [_] 3))

(deftype Ln [expr]
  Stringable
  (string-list [_]
    (comp (cons "ln(" (string-list expr))
          (list ")")))

  Precedence
  (size [_]
    (size expr)))

(defprotocol Operations
  (d [f x])

  (add [f g]
    (either (or (and (= 0 g) (maybe f))
                (and (instance? Integer g)
                     (maybe (Add g f)))
                (and (instance? Add g)
                     (map (instance? Integer (.f g))
                          (fn [f-g]
                            (add f-g (add f (.g g)))))))
            (Add f g)))

  (mul [f g]
    (either (or (= 0 g)
                (and (= 1 g) (maybe f))
                (and (instance? Integer g)
                     (maybe (mul g f)))
                (and (instance? Mul g)
                     (map (instance? Integer (.f g))
                          (fn [f-g]
                            (mul f-g (mul f (.g g)))))))
            (Mul f g)))

  (pow [f g]
    (either (or (and (= 0 g) (maybe 1))
                (and (= 1 g) (maybe f)))
            (Pow f g)))

  (ln [f]
    (either (and (= 1 f) (maybe 0))
            (Ln f))))

(defn pown [a n]
  (assert (instance? Integer a))
  (assert (instance? Integer n))

  (either (or (and (= 0 n) (maybe 1))
              (and (= 1 n) (maybe a)))
          (let [b (pown a (div n 2))
                x (either (and (= 0 (rem n 2))
                               (maybe 1))
                          a)]
            (* b b x))))


(extend-type Add
  Operations
  (add [a h]
    (.g a (add (.g a) h)))

  (d [a x]
    (-> a
        (.f (d (.f a) x))
        (.g (d (.g a) x)))))

(extend-type Mul
  Operations
  (mul [m h]
    (mul (.f m) (mul (.g m) h)))

  (d [m x]
    (let [f (.f m)
          g (.g m)]
      (add (mul f (d g x))
           (mul g (d f x))))))

(extend-type Pow
  Operations
  (d [p x]
    (let [f (.f p)
          g (.g p)]
      (mul (pow f g)
           (add (mul (mul g (d f x)) (.g p -1))
                (mul (ln f) (d g x)))))))


(extend-type Ln
  Operations
  (d [l x]
    (let [expr (.expr l)]
      (mul (d expr x) (pow expr -1)))))

(extend-type String
  Operations
  (d [f x]
    (either (and (= f x)
                 (maybe 1))
            0))

  Precedence
  (size [_]
    1))

(extend-type Integer
  Operations
  (d [n x]
    0)

  (add [f g]
    (either (or (and (= 0 f) (maybe g))
                (map (instance? Integer g)
                     (fn [g]
                       (* f g))))
            (Add f g)))

  (mul [f g]
    (either (or (and (= 1 f)
                     (maybe g))
                (map (instance? Integer g)
                     (fn [g]
                       (* f g))))
            (Mul f g)))

  (pow [f g]
    (either (or (= 0 f)
                (map (instance? Integer g)
                     (fn [g]
                       (pown f g))))
            (Pow f g)))

  Precedence
  (size [_]
    1))

(defn show [expr]
  (either (map (> (size expr) 100)
               (fn [sz]
                 (str "<<" sz ">>")))
          (str expr)))

(defn nest [n f x]
  (either (and (= 0 n)
               (maybe x))
          (nest (dec n) f (f x))))

(defn deriv [f]
  (let [d-prime (d f "x")]
    (println (str "D("
                  (show f)
                  ") = " (show d-prime)))
    d-prime))

(main [_]
  (nest 10 deriv (Pow "x" "x")))
